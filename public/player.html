<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Boombox ‚Ä¢ Zen</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css"/>
<link rel="stylesheet" href="/styles.css"/>
</head>
<body>
<div class="particles" id="particles"></div>

<nav class="navbar navbar-light bg-light shadow-sm">
  <div class="container">
    <a class="btn btn-link" href="/"><i class="bi-arrow-left"></i> Back</a>
    <span class="navbar-text"><i class="bi-music-note-list mr-1"></i> Boombox</span>
  </div>
</nav>

<div class="container py-4">
  <div class="row">
    <div class="col-lg-6 mb-3">
      <div class="panel">
        <h5 class="mb-3"><i class="bi-collection"></i> Library</h5>
        <div class="input-group mb-3">
          <select class="custom-select" id="fileSelect">
            <option disabled selected>‚Äî files will appear here ‚Äî</option>
          </select>
          <div class="input-group-append">
            <button id="refresh" class="btn btn-outline-secondary"><i class="bi-arrow-clockwise"></i></button>
          </div>
        </div>
        <div class="d-flex">
          <button id="play" class="btn btn-ice mr-2" disabled><i class="bi-play-fill"></i> Play</button>
          <button id="stop" class="btn btn-outline-secondary" disabled><i class="bi-stop-fill"></i> Stop</button>
        </div>
      </div>
    </div>

    <div class="col-lg-6 mb-3">
      <div class="panel">
        <h5 class="mb-3"><i class="bi-volume-up"></i> Volume</h5>
        <input type="range" class="custom-range" id="vol" min="0" max="100" value="70">
        <div class="meta mt-2"><span id="volVal">70%</span></div>
      </div>
    </div>

    <div class="col-12 mb-3">
      <div class="panel">
        <h5 class="mb-3"><i class="bi-mic"></i> Voice Control</h5>
        <div class="row">
          <div class="col-md-6">
            <div class="d-flex mb-2">
              <button id="voiceInit" class="btn btn-outline-primary mr-2">
                <i class="bi-mic"></i> Initialize Voice
              </button>
              <button id="voiceStart" class="btn btn-success mr-2" disabled>
                <i class="bi-mic-fill"></i> Start Listening
              </button>
              <button id="voiceStop" class="btn btn-danger" disabled>
                <i class="bi-mic-mute"></i> Stop Listening
              </button>
            </div>
            <div class="d-flex mb-2">
              <button id="voiceFeedback" class="btn btn-outline-info mr-2">
                <i class="bi-volume-up"></i> Toggle Feedback
              </button>
              <button id="voiceTest" class="btn btn-outline-secondary">
                <i class="bi-chat"></i> Test Voice
              </button>
            </div>
          </div>
          <div class="col-md-6">
            <div class="voice-status">
              <small class="text-muted">
                Status: <span id="voiceStatus">Not initialized</span><br>
                Listening: <span id="voiceListening">No</span><br>
                Feedback: <span id="voiceFeedbackStatus">Enabled</span>
              </small>
            </div>
            <div class="mt-2">
              <small class="text-muted">
                <strong>Voice Commands:</strong><br>
                "Play", "Pause", "Next", "Previous"<br>
                "Volume Up", "Volume Down", "What Song", "Help"
              </small>
            </div>
          </div>
        </div>
        <div id="voiceCommands" class="mt-2" style="display: none;">
          <div class="alert alert-info">
            <strong>Voice Command Detected:</strong> <span id="lastCommand">None</span>
          </div>
        </div>
      </div>
    </div>

    <div class="col-12">
      <div class="panel">
        <h5 class="mb-3"><i class="bi-activity"></i> VU Meter</h5>
        <canvas id="vu" height="80"></canvas>
        <audio id="ghost" preload="auto" crossorigin="anonymous"></audio>
        <div class="mt-2">
          <small class="text-muted">
            Status: <span id="audioStatus">Ready</span> | 
            Mode: <span id="audioMode">Cloud</span> | 
            File: <span id="currentFile">None</span>
          </small>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="/scripts.js"></script>
<script>
const $ = s => document.querySelector(s);
const file = $('#fileSelect'), play=$('#play'), stopBtn=$('#stop'), vol=$('#vol'), volVal=$('#volVal');
let ghost = document.getElementById('ghost'), canvas=document.getElementById('vu'), ctx=canvas.getContext('2d');
const audioStatus = $('#audioStatus'), audioMode = $('#audioMode'), currentFile = $('#currentFile');
let audioCtx, analyser, data;

// Update status display
function updateStatus(status, file = null) {
  audioStatus.textContent = status;
  if (file) currentFile.textContent = file;
}

// Reset audio element state
function resetAudio() {
  // Close existing audio context first
  if (audioCtx) {
    console.log('Closing audio context during reset');
    audioCtx.close();
    audioCtx = null;
    analyser = null;
    data = null;
  }
  
  // Create a completely new audio element to avoid connection issues
  const newGhost = document.createElement('audio');
  newGhost.id = 'ghost';
  newGhost.preload = 'auto';
  newGhost.crossOrigin = 'anonymous';
  newGhost.volume = 0.7;
  
  // Replace the old audio element
  ghost.parentNode.replaceChild(newGhost, ghost);
  
  // Update the global reference
  ghost = newGhost;
  
  // Re-attach event listeners
  newGhost.addEventListener('loadedmetadata', () => {
    console.log('Audio metadata loaded');
    console.log('Duration:', newGhost.duration);
    console.log('Current volume:', newGhost.volume);
  });

  newGhost.addEventListener('canplay', () => {
    console.log('Audio can play');
  });

  newGhost.addEventListener('error', (e) => {
    console.error('Audio error:', e);
    console.error('Error details:', newGhost.error);
  });
  
  console.log('Audio element completely replaced');
}

// Audio event handlers
ghost.onloadstart = () => updateStatus('Loading...');
ghost.oncanplay = () => updateStatus('Ready to play');
ghost.onplay = () => updateStatus('Playing');
ghost.onpause = () => updateStatus('Paused');
ghost.onended = () => updateStatus('Ended');
ghost.onerror = (e) => updateStatus('Error: ' + (e.message || 'Unknown error'));

// Set initial volume
ghost.volume = 0.7;

async function loadFiles(){
  try{
    const refreshBtn = document.getElementById('refresh');
    refreshBtn.disabled = true;
    refreshBtn.innerHTML = '<i class="bi-arrow-clockwise"></i>';
    
    const r = await fetch('/api/audio/files'); 
    if (!r.ok) {
      throw new Error(`Server error: ${r.status}`);
    }
    
    const list = await r.json();
    if (list && list.length > 0) {
      file.innerHTML = list.map(f=>`<option>${f}</option>`).join('');
      file.disabled = false;
    } else {
      file.innerHTML = '<option disabled>No audio files found</option>';
      file.disabled = true;
    }
  } catch (error) {
    console.error('Failed to load files:', error);
    file.innerHTML = '<option disabled>Error loading files</option>';
    file.disabled = true;
  } finally {
    const refreshBtn = document.getElementById('refresh');
    refreshBtn.disabled = false;
    refreshBtn.innerHTML = '<i class="bi-arrow-clockwise"></i>';
  }
}
document.getElementById('refresh').onclick = loadFiles;
file.onchange = e => {
  const selectedFile = e.target.value;
  const hasValidFile = selectedFile && selectedFile !== '‚Äî files will appear here ‚Äî' && !selectedFile.includes('Error') && !selectedFile.includes('No audio');
  
  console.log('File change event:', selectedFile, 'Valid:', hasValidFile);
  
  play.disabled = !hasValidFile;
  stopBtn.disabled = !hasValidFile;
  
  if (hasValidFile) {
    // Reset audio element state for new file
    resetAudio();
    
    // Reset button state
    play.classList.remove('btn-success');
    play.innerHTML = '<i class="bi-play-fill"></i> Play';
    
    // Reset status
    updateStatus('Ready', selectedFile);
    
    console.log('New file selected:', selectedFile);
    console.log('Audio element after reset - src:', ghost.src, 'readyState:', ghost.readyState);
  }
};

play.onclick = async ()=>{
  const f = file.value; 
  if(!f || f === '‚Äî files will appear here ‚Äî') {
    alert('Please select a file to play first');
    return;
  }
  
  console.log('Attempting to play:', f);
  console.log('Current audio src:', ghost.src);
  console.log('Current audio state:', ghost.readyState);
  
  try {
    play.disabled = true;
    play.innerHTML = '<i class="bi-hourglass-split"></i> Playing...';
    
    // Always set new source for new file (prevents caching issues)
    const newSrc = `/api/audio/stream/${encodeURIComponent(f)}`;
    console.log('Setting new source:', newSrc);
    ghost.src = newSrc;
    updateStatus('Loading...', f);
    
    // Reset audio state
    ghost.currentTime = 0;
    
    // Wait for audio to be ready
    await new Promise((resolve, reject) => {
      const onCanPlay = () => {
        console.log('Audio can play, readyState:', ghost.readyState);
        ghost.removeEventListener('canplay', onCanPlay);
        ghost.removeEventListener('error', onError);
        clearTimeout(timeoutId);
        resolve();
      };
      
      const onError = (error) => {
        console.error('Audio load error:', error);
        ghost.removeEventListener('canplay', onCanPlay);
        ghost.removeEventListener('error', onError);
        clearTimeout(timeoutId);
        reject(error);
      };
      
      ghost.addEventListener('canplay', onCanPlay);
      ghost.addEventListener('error', onError);
      
      // Timeout after 5 seconds
      const timeoutId = setTimeout(() => {
        console.error('Audio load timeout');
        ghost.removeEventListener('canplay', onCanPlay);
        ghost.removeEventListener('error', onError);
        reject(new Error('Audio load timeout'));
      }, 5000);
    });
    
    // Ensure audio context is resumed (browser requirement)
    if (audioCtx && audioCtx.state === 'suspended') {
      await audioCtx.resume();
    }
    
    // Try to play the audio
    const playPromise = ghost.play();
    if (playPromise !== undefined) {
      await playPromise;
      await startVU();
      play.innerHTML = '<i class="bi-pause-fill"></i> Playing';
      play.classList.add('btn-success');
      updateStatus('Playing', f);
    }
    
  } catch (error) {
    console.error('Play error:', error);
    
    // Handle specific browser audio permission errors
    if (error.name === 'NotAllowedError') {
      alert('Please click the play button again to allow audio playback');
      // Reset button state
      play.innerHTML = '<i class="bi-play-fill"></i> Play';
      play.classList.remove('btn-success');
    } else {
      alert('Failed to play audio: ' + error.message);
    }
  } finally {
    play.disabled = false;
  }
};
stopBtn.onclick = async ()=>{
  try {
    stopBtn.disabled = true;
    const response = await fetch('/api/audio/stop', {method:'POST'});
    if (response.ok) {
      ghost.pause();
      ghost.currentTime = 0;
      play.innerHTML = '<i class="bi-play-fill"></i> Play';
      play.classList.remove('btn-success');
      if (audioCtx) {
        audioCtx.close();
        audioCtx = null;
        analyser = null;
        data = null;
      }
    }
  } catch (error) {
    console.error('Stop error:', error);
  } finally {
    stopBtn.disabled = false;
  }
};
vol.oninput = async e => {
  const volume = e.target.value;
  volVal.textContent = volume + '%';
  
  // Set volume on the audio element (works in cloud mode)
  ghost.volume = volume / 100;
  console.log('Audio volume set to:', ghost.volume);
  
  // Also try to set system volume (works on Linux/Unix, not Windows)
  try {
    const response = await fetch('/api/audio/volume/'+volume, {method:'POST'});
    if (response.ok) {
      const result = await response.json();
      if (result.mode === 'pi') {
        console.log('System volume set to:', volume + '%');
      } else {
        console.log('Using browser volume control (system volume not available)');
      }
    }
  } catch (error) {
    console.log('System volume control not available (using browser volume)');
  }
};

async function startVU(){
  try {
    // Check if audio element is already connected
    if (audioCtx && audioCtx.state !== 'closed') {
      console.log('Audio context already exists and active');
      return; // Don't recreate if already working
    }
    
    // Create new audio context only if needed
    if (!audioCtx || audioCtx.state === 'closed') {
      console.log('Creating new audio context');
      audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      
      // Check if audio context is suspended and resume if needed
      if (audioCtx.state === 'suspended') {
        await audioCtx.resume();
        console.log('Audio context resumed');
      }
      
      const node = audioCtx.createMediaElementSource(ghost);
      analyser = audioCtx.createAnalyser(); 
      analyser.fftSize = 1024;
      data = new Uint8Array(analyser.frequencyBinCount);
      node.connect(analyser); 
      analyser.connect(audioCtx.destination);
      
      console.log('VU meter initialized, audio context state:', audioCtx.state);
    }
    
    draw();
  } catch (error) {
    console.error('VU meter setup failed:', error);
    // Continue without VU meter if it fails
  }
}
function draw(){
  requestAnimationFrame(draw); if(!analyser) return;
  analyser.getByteFrequencyData(data);
  const w = canvas.width = canvas.clientWidth, h = canvas.height = canvas.clientHeight;
  ctx.clearRect(0,0,w,h);
  const bars = 40, step = Math.floor(data.length/bars);
  for(let i=0;i<bars;i++){
    let s=0; for(let j=0;j<step;j++) s+=data[i*step+j];
    const v = (s/step)/255, bh = v*h;
    const x=(w/bars)*i+2, bw=(w/bars)-4;
    ctx.fillStyle = '#38bdf8'; ctx.fillRect(x, h-bh, bw, bh);
  }
}
// Voice Control System
const voiceInit = $('#voiceInit');
const voiceStart = $('#voiceStart');
const voiceStop = $('#voiceStop');
const voiceFeedback = $('#voiceFeedback');
const voiceTest = $('#voiceTest');
const voiceStatus = $('#voiceStatus');
const voiceListening = $('#voiceListening');
const voiceFeedbackStatus = $('#voiceFeedbackStatus');
const voiceCommands = $('#voiceCommands');
const lastCommand = $('#lastCommand');

let voiceActive = false;

// Set initial button states
voiceStart.disabled = true;
voiceStop.disabled = true;
voiceStart.classList.add('btn-outline-success');
voiceStart.classList.remove('btn-success');
voiceStop.classList.add('btn-outline-danger');
voiceStop.classList.remove('btn-danger');

console.log('üé§ Voice control buttons initialized with correct states');

// Remove old Socket.IO and polling code - we're using real voice recognition now

// Initialize voice service
  // Voice control button handlers
  voiceInit.onclick = async () => {
    try {
      voiceInit.disabled = true;
      voiceStart.disabled = true; // Keep start button disabled during init
      voiceInit.innerHTML = '<i class="bi-hourglass-split"></i> Initializing...';
      
      // Initialize real voice recognition
      if (initVoiceRecognition()) {
        voiceStatus.innerHTML = '<i class="bi-check-circle"></i> Voice Ready';
        voiceStatus.style.color = '#28a745';
        voiceInit.innerHTML = '<i class="bi-check-circle"></i> Voice Ready';
        voiceInit.disabled = false;
        
        // Enable the start listening button
        voiceStart.disabled = false;
        voiceStart.innerHTML = '<i class="bi-mic"></i> Start Listening';
        voiceStart.classList.remove('btn-outline-success');
        voiceStart.classList.add('btn-success');
        
        console.log('‚úÖ Voice recognition ready - Start Listening button enabled');
      } else {
        voiceStatus.innerHTML = '<i class="bi-x-circle"></i> Voice Not Supported';
        voiceStatus.style.color = '#dc3545';
        voiceInit.innerHTML = '<i class="bi-x-circle"></i> Retry';
        voiceInit.disabled = false;
        
        // Keep start button disabled
        voiceStart.disabled = true;
        voiceStart.innerHTML = '<i class="bi-mic-slash"></i> Not Available';
        voiceStart.classList.remove('btn-success');
        voiceStart.classList.add('btn-outline-secondary');
      }
    } catch (error) {
      console.error('Voice init error:', error);
      voiceStatus.innerHTML = '<i class="bi-x-circle"></i> Error';
      voiceStatus.style.color = '#dc3545';
      voiceInit.innerHTML = '<i class="bi-arrow-clockwise"></i> Retry';
      voiceInit.disabled = false;
      
      // Keep start button disabled
      voiceStart.disabled = true;
    }
  };

  voiceStart.onclick = () => {
    if (!recognition) {
      alert('Please initialize voice recognition first!');
      return;
    }
    
    startVoiceRecognition();
    
    // Update button states
    voiceStart.disabled = true;
    voiceStart.innerHTML = '<i class="bi-mic-fill"></i> Listening...';
    voiceStart.classList.remove('btn-success');
    voiceStart.classList.add('btn-warning');
    
    voiceStop.disabled = false;
    voiceStop.classList.remove('btn-outline-danger');
    voiceStop.classList.add('btn-danger');
    
    voiceListening.innerHTML = '<i class="bi-mic-fill"></i> Listening...';
    voiceListening.style.color = '#28a745';
    
    console.log('üé§ Voice recognition started - buttons updated');
  };

  voiceStop.onclick = () => {
    stopVoiceRecognition();
    
    // Update button states
    voiceStart.disabled = false;
    voiceStart.innerHTML = '<i class="bi-mic"></i> Start Listening';
    voiceStart.classList.remove('btn-warning');
    voiceStart.classList.add('btn-success');
    
    voiceStop.disabled = true;
    voiceStop.classList.remove('btn-danger');
    voiceStop.classList.add('btn-outline-danger');
    
    voiceListening.innerHTML = '<i class="bi-mic"></i> Not Listening';
    voiceListening.style.color = '#6c757d';
    
    console.log('üîá Voice recognition stopped - buttons updated');
  };

// Toggle voice feedback
voiceFeedback.onclick = async () => {
  try {
    voiceFeedback.disabled = true;
    voiceFeedback.innerHTML = '<i class="bi-hourglass-split"></i> Toggling...';
    
    const response = await fetch('/api/voice/feedback/toggle', { method: 'POST' });
    const result = await response.json();
    
    if (result.success) {
      voiceFeedbackStatus.textContent = result.voiceFeedback ? 'Enabled' : 'Disabled';
      voiceFeedback.innerHTML = result.voiceFeedback ? 
        '<i class="bi-volume-up"></i> Disable Feedback' : 
        '<i class="bi-volume-mute"></i> Enable Feedback';
    }
  } catch (error) {
    console.error('Voice feedback toggle error:', error);
  } finally {
    voiceFeedback.disabled = false;
  }
};

// Test voice
voiceTest.onclick = () => {
  if (!recognition) {
    alert('Please initialize voice recognition first!');
    return;
  }
  
  // Test the voice feedback by speaking a test message
  const testMessage = 'Voice control system is working. Hello from your BOOM box!';
  console.log('üé§ Test message:', testMessage);
  
  // You can also test the text-to-speech by calling the server
  fetch('/api/voice/speak', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ text: testMessage })
  }).then(response => response.json())
    .then(result => {
      if (result.success) {
        console.log('‚úÖ Text-to-speech test successful');
      }
    })
    .catch(error => console.error('Text-to-speech test error:', error));
};

// Manual test button for debugging
const manualTestBtn = document.createElement('button');
manualTestBtn.innerHTML = '<i class="bi-bug"></i> Manual Test';
manualTestBtn.className = 'btn btn-warning btn-sm ms-2';
manualTestBtn.onclick = () => {
  console.log('üß™ Manual test: Simulating voice command "play"');
  handleVoiceCommand('play');
};
  
// Add manual test button after the voice test button
voiceTest.parentNode.appendChild(manualTestBtn);

// Voice recognition using Web Speech API
let recognition = null;
let isListening = false;

// Initialize voice recognition
function initVoiceRecognition() {
  console.log('üé§ Initializing voice recognition...');
  console.log('Browser support check:');
  console.log('- SpeechRecognition:', 'SpeechRecognition' in window);
  console.log('- webkitSpeechRecognition:', 'webkitSpeechRecognition' in window);
  
  if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
    try {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognition = new SpeechRecognition();
      
      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.lang = 'en-US';
      
      recognition.onstart = () => {
        console.log('üé§ Voice recognition started');
        voiceListening.innerHTML = '<i class="bi-mic-fill"></i> Listening...';
        voiceListening.style.color = '#28a745';
      };
      
      recognition.onresult = (event) => {
        const command = event.results[0][0].transcript.toLowerCase().trim();
        console.log('üé§ Voice command recognized:', command);
        lastCommand.innerHTML = `<strong>Last Command:</strong> ${command}`;
        
        // Process the voice command
        handleVoiceCommand(command);
      };
      
      recognition.onerror = (event) => {
        console.error('Voice recognition error:', event.error);
        voiceListening.innerHTML = '<i class="bi-mic-slash"></i> Error';
        voiceListening.style.color = '#dc3545';
      };
      
      recognition.onend = () => {
        console.log('üé§ Voice recognition ended');
        if (isListening) {
          // Restart listening if still enabled
          setTimeout(() => {
            if (isListening) {
              recognition.start();
            }
          }, 100);
        } else {
          voiceListening.innerHTML = '<i class="bi-mic"></i> Not Listening';
          voiceListening.style.color = '#6c757d';
        }
      };
      
      console.log('‚úÖ Voice recognition initialized successfully');
      return true;
    } catch (error) {
      console.error('‚ùå Error creating SpeechRecognition:', error);
      return false;
    }
  } else {
    console.error('‚ùå Speech recognition not supported in this browser');
    console.log('üí° Try using Chrome, Edge, or Safari for voice recognition');
    return false;
  }
}

// Start voice recognition
function startVoiceRecognition() {
  if (!recognition) {
    if (!initVoiceRecognition()) {
      alert('Voice recognition not supported in your browser. Try Chrome or Edge.');
      return;
    }
  }
  
  isListening = true;
  recognition.start();
}

// Stop voice recognition
function stopVoiceRecognition() {
  isListening = false;
  if (recognition) {
    recognition.stop();
  }
}

// Handle voice commands from server
async function handleVoiceCommand(command) {
  console.log('Voice command received:', command);
  
  // Show command in UI
  lastCommand.textContent = command;
  voiceCommands.style.display = 'block';
  
  // Hide command display after 3 seconds
  setTimeout(() => {
    voiceCommands.style.display = 'none';
  }, 3000);
  
  // Execute command based on voice input
  switch (command) {
    case 'play':
      if (file.value && file.value !== '‚Äî files will appear here ‚Äî') {
        console.log('üéµ Voice command: Playing music');
        play.click();
      } else {
        console.log('‚ùå Voice command: No file selected');
        // Speak feedback
        fetch('/api/voice/speak', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text: 'Please select a file first' })
        });
      }
      break;
      
    case 'pause':
      if (ghost.paused === false) {
        console.log('‚è∏Ô∏è Voice command: Pausing music');
        ghost.pause();
        play.innerHTML = '<i class="bi-play-fill"></i> Play';
        play.classList.remove('btn-success');
        updateStatus('Paused', file.value);
      }
      break;
      
    case 'volume up':
      const newVolUp = Math.min(100, parseInt(vol.value) + 10);
      console.log('üîä Voice command: Volume up to', newVolUp + '%');
      vol.value = newVolUp;
      volVal.textContent = newVolUp + '%';
      ghost.volume = newVolUp / 100;
      vol.dispatchEvent(new Event('input'));
      break;
      
    case 'volume down':
      const newVolDown = Math.max(0, parseInt(vol.value) - 10);
      console.log('üîâ Voice command: Volume down to', newVolDown + '%');
      vol.value = newVolDown;
      volVal.textContent = newVolDown + '%';
      ghost.volume = newVolDown / 100;
      vol.dispatchEvent(new Event('input'));
      break;
      
    case 'what song':
      const currentSong = file.value || 'No song selected';
      console.log('üé§ Voice command: Current song is', currentSong);
      fetch('/api/voice/speak', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text: `Currently playing: ${currentSong}` })
      });
      break;
      
    case 'help':
      console.log('‚ùì Voice command: Showing help');
      fetch('/api/voice/speak', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text: 'Available commands: play, pause, volume up, volume down, what song, and help' })
      });
      break;
      
    case 'test':
      console.log('üß™ Test voice command received - frontend communication working!');
      // Show success message
      lastCommand.textContent = 'TEST SUCCESS - Frontend communication working!';
      voiceCommands.style.display = 'block';
      setTimeout(() => {
        voiceCommands.style.display = 'none';
      }, 5000);
      break;
      
    default:
      console.log('‚ùì Voice command not recognized:', command);
  }
}

// Add debug info
console.log('Player initialized');
console.log('Audio element:', ghost);
console.log('Initial volume:', ghost.volume);

// Test audio element
ghost.addEventListener('loadedmetadata', () => {
  console.log('Audio metadata loaded');
  console.log('Duration:', ghost.duration);
  console.log('Current volume:', ghost.volume);
});

ghost.addEventListener('canplay', () => {
  console.log('Audio can play');
});

ghost.addEventListener('error', (e) => {
  console.error('Audio error:', e);
  console.error('Error details:', ghost.error);
});

loadFiles();
</script>
</body>
</html>